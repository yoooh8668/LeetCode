bool palindromic (char * s,int i, int j)
{
    if (((j-i+1)%2)==0) //even
    {
        //printf("EVEN case\n");
        for(int k=j; k>(j-k+i) ; k--)
        {
            if (s[(j-k+i)] != s[k])
            {
                //printf("NOT MATCH!!\n\n");
                return false;   
            }
        }
    }
    else                //odd
    {
        //printf("ODD case\n");
        for(int k=j; k>(j-k+i) ; k--)
        {
            if (s[(j-k+i)] != s[k])
            {
                //printf("NOT MATCH!!\n\n");
                return false;   
            }
        }
    }
    return true;
}


char * longestPalindrome(char * s){
    int sLen = strlen(s);
    printf("sLen = %d\n",sLen);
    char maxStr[(sLen+1)];
    char *result = &maxStr;
    if (sLen == 0)
    {
        maxStr[0] = '\0';
        return result;   
    }

    //+++finding palindromic here
    int currentLen = 1;
    int j=0;//max palindromic posision for current i
    bool ifPalindromic = false;
    for (int i=0 ;s[i] ; i++)
    {
        for(j=(sLen-1) ; j !=i ; j--)
        {
            //printf("i = %d,j = %d \n",i,j);
            ifPalindromic = palindromic(s,i,j);
            if ((ifPalindromic && ((j-i+1) > currentLen)))
            {
                //printf("Max palindromic for (i = %d) \nis  (j = %d)\n\n",i,j);
                for (int k=i ; k<=j ; k++)
                {
                    maxStr[(k-i)] = s[k];
                }
                maxStr[(j -i + 1)] = '\0';
                currentLen = j-i+1;
                break;
            }
        }
    }
    //---finding palindromic here
    if (currentLen == 1)
    {
        maxStr[0] = s[0];
        maxStr[1] = '\0';
        return result;
    }
    else 
    {
        maxStr[sLen] = '\0';
        return result;
    }
}
