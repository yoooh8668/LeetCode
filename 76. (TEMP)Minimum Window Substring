/***********************************************
1. For string s, and t. 
   Sort t first, than search t[0] from s[0], search t[1] from s[0]...
   If t[n]is at s[k] and t[n+1]==t[n], search t[n+1] from s[k+1].
   And for next condition, remove one char from s[n], research from s[n+1] to get a new result.
***********************************************/
void searchWidth (int* tIndex, int tLen, int* result){
    result[1]=-1;
    result[0]=100000;
    for (int i=0 ; i<tLen ; i++)
    {
        result[0]=(result[0]<tIndex[i])?result[0]:tIndex[i];
        result[1]=(result[1]>tIndex[i])?result[1]:tIndex[i];
    }
}

char * minWindow(char * s, char * t){
    int sLen=strlen(s);
    int tLen=strlen(t);
    char* result=malloc(sizeof(char)*(sLen+1));
    char temp;
    for (int i = 0; i < tLen; i++) 
    {
        for (int j = 0; j < i; j++) 
        {
            if (t[j] > t[i])
            {
                temp = t[j];
                t[j] = t[i];
                t[i] = temp;
            }
        }
    }
    int tIndex[tLen];
    int shift=0;
    char* searchResult;
    for (int i=0 ;i<tLen ; i++)
    {
        if (i>0 && t[i]==t[i-1])
        {
            shift=tIndex[i-1]+1;
            searchResult=strchr(s+shift,t[i]);
            if (searchResult==NULL)
            {
                result[0]='\0';
                return result;
            }
            tIndex[i]=searchResult-s;
        }
        else
        {
            searchResult=strchr(s,t[i]);
            if (searchResult==NULL)
            {
                result[0]='\0';
                return result;
            }
            tIndex[i]=searchResult-s;
        }
    }
    int* index=malloc(sizeof(int)*2);
    searchWidth(tIndex, tLen, index);
    printf("first search = %d, %d\n",index[0],index[1]);
    
    while(1)
    {
        searchResult=strchr(s+shift,t[i]);
        if (searchResult==NULL)
            break;
        else 
        {
            
        }
    }
    
    //Put in result
    int count=0;
    for (int i=index[0] ; i<=index[1] ;i++)
        result[count++]=s[i];
    result[count]='\0';
    return result;
}

/************************************************
0. Using dp search,
   This way can't handle t which contain repeated char.
*************************************************/
void findMinMatch(int** dp, int n, int m, int* result){
    int *index=malloc(sizeof(int)*n);
    for (int i=0 ; i<n ; i++)
        index[i]=-1;
    int allElementReady=0;
    for (int j=0 ; j<m ; j++)
    {
        for (int i=0 ;i<n ;i++)
        {
            if (dp[i][j]==1)
            {
                if (index[i]==-1)
                    allElementReady++;
                index[i]=j;
                if (allElementReady==n)
                    searchWidth(index, n, result);
                break;
            }
        }
    }
    free(index);
    return result;
}

void searchWidth(int* index, int n, int* result){   
    int startTemp=index[0];
    int endTemp=index[0];
    for (int i=0 ; i<n ;i++)
    {
        if (startTemp > index[i])
            startTemp=index[i];
        if (endTemp < index[i])
            endTemp=index[i];
    }
    
    if (result[1]-result[0] > endTemp-startTemp)
    {
        result[0]=startTemp;
        result[1]=endTemp;
    }
}

char * minWindow(char * s, char * t){
    int sLen = strlen(s);
    int tLen = strlen(t);
    
    //sort t and remove the same char.
    char temp;
    
    int** dp=malloc(sizeof(int*)*tLen);
    for (int i=0 ; i<tLen ; i++)
    {
        dp[i]=malloc(sizeof(int)*sLen);
        for (int j=0 ; j<sLen ;j++)
        {
            if (t[i]==s[j])
                dp[i][j]=1;
            else 
                dp[i][j]=0;
        }
    }
    int *resultIndex=malloc(sizeof(int)*2);
    resultIndex[0]=-1;
    resultIndex[1]=sLen+1;
    findMinMatch(dp, tLen, sLen, resultIndex);
    
    char* result=malloc(sizeof(char)*(resultIndex[1]-resultIndex[0]+2));
    int count=0;
    if (resultIndex[0]!=-1)
    {
        for (int i=resultIndex[0] ; i<=resultIndex[1] ; i++)
        {
                result[count++]=s[i];
        }
    }
    result[count]='\0';
    
    for (int i=0 ; i<tLen ; i++)
        free(dp[i]);
    free(dp);
    free(resultIndex);
    
    return result;
}
