/***********************************************
1. For string s, and t. 
   Sort t first, than search t[0] from s[0], search t[1] from s[0]...
   If t[n]is at s[k] and t[n+1]==t[n], search t[n+1] from s[k+1].
   And for next condition, remove one char from s[n], research from s[n+1] to get a new result.
***********************************************/
#define MIN(x,y) ((x)<(y))?(x):(y)
#define MAX(x,y) ((x)>(y))?(x):(y)
void searchWidth (int* tIndex, int tLen, int* result){
    result[1]=-1;
    result[0]=100000;
    for (int i=0 ; i<tLen ; i++)
    {
        if (result[0]>tIndex[i])
        {
            result[0]=tIndex[i];
            result[2]=i;
        }
        result[1]=MAX(result[1],tIndex[i]);
    }
    //printf("section = %d , %d \n",result[0], result[1]);
    //printf("min i=%d\n",result[2]);
}

int largestSameChar (char* t, int* tIndex, int tLen, int* result){
    int max=-1;
    for (int i=result[2]+1; i<tLen; i++)
    {
        if (t[i]==t[result[2]] && tIndex[i]>max)
            max=tIndex[i];
    }
    for (int i=result[2]-1 ; i>=0 ; i--)
    {
        if (t[i]==t[result[2]] && tIndex[i]>max)
            max=tIndex[i];
    }
    //printf("largestSameChar=%d\n",max);
    return max;
}

char * minWindow(char * s, char * t){
    int sLen=strlen(s);
    int tLen=strlen(t);
    char* result=malloc(sizeof(char)*(sLen+1));
    char temp;
    //sort temp
    for (int i = 0; i < tLen; i++) 
    {
        for (int j = 0; j < i; j++) 
        {
            if (t[j] > t[i])
            {
                temp = t[j];
                t[j] = t[i];
                t[i] = temp;
            }
        }
    }
    int tIndex[tLen];
    int shift=0;
    char* searchResult;
    
    //first time search
    for (int i=0 ;i<tLen ; i++)
    {
        if (i>0 && t[i]==t[i-1])
        {
            shift=tIndex[i-1]+1;
            searchResult=strchr(s+shift,t[i]);
            if (searchResult==NULL)
            {
                result[0]='\0';
                return result;
            }
            tIndex[i]=searchResult-s;
        }
        else
        {
            searchResult=strchr(s,t[i]);
            if (searchResult==NULL)
            {
                result[0]='\0';
                return result;
            }
            tIndex[i]=searchResult-s;
        }
    }
    int* index=malloc(sizeof(int)*3);
    //index[start,end,i] , where t[i]=start
    //printf("first search = ");
    searchWidth(tIndex, tLen, index);
    int start = index[0];
    int end = index[1];
    
    while( (end-start+1) != tLen)
    {
        //printf("continue search for t[%d]=%c\n",index[2],t[index[2]]);
        shift = largestSameChar(t, tIndex, tLen, index)+1;
        if (shift == 0)
            shift=index[0]+1;
        
        searchResult=strchr(s+shift,t[index[2]]);
        if (searchResult==NULL)
           break;
        tIndex[index[2]]=searchResult-s;
        searchWidth(tIndex, tLen, index);
        if (end-start > index[1]-index[0])
        {
            //printf("change section\n");
            start=index[0];
            end=index[1];
        }
    }
    
    //Put in result
    int count=0;
    for (int i=start ; i<=end ;i++)
        result[count++]=s[i];
    result[count]='\0';
    return result;
}

/************************************************
0. Using dp search,
   This way can't handle t which contain repeated char.
*************************************************/
void findMinMatch(int** dp, int n, int m, int* result){
    int *index=malloc(sizeof(int)*n);
    for (int i=0 ; i<n ; i++)
        index[i]=-1;
    int allElementReady=0;
    for (int j=0 ; j<m ; j++)
    {
        for (int i=0 ;i<n ;i++)
        {
            if (dp[i][j]==1)
            {
                if (index[i]==-1)
                    allElementReady++;
                index[i]=j;
                if (allElementReady==n)
                    searchWidth(index, n, result);
                break;
            }
        }
    }
    free(index);
    return result;
}

void searchWidth(int* index, int n, int* result){   
    int startTemp=index[0];
    int endTemp=index[0];
    for (int i=0 ; i<n ;i++)
    {
        if (startTemp > index[i])
            startTemp=index[i];
        if (endTemp < index[i])
            endTemp=index[i];
    }
    
    if (result[1]-result[0] > endTemp-startTemp)
    {
        result[0]=startTemp;
        result[1]=endTemp;
    }
}

char * minWindow(char * s, char * t){
    int sLen = strlen(s);
    int tLen = strlen(t);
    
    //sort t and remove the same char.
    char temp;
    
    int** dp=malloc(sizeof(int*)*tLen);
    for (int i=0 ; i<tLen ; i++)
    {
        dp[i]=malloc(sizeof(int)*sLen);
        for (int j=0 ; j<sLen ;j++)
        {
            if (t[i]==s[j])
                dp[i][j]=1;
            else 
                dp[i][j]=0;
        }
    }
    int *resultIndex=malloc(sizeof(int)*2);
    resultIndex[0]=-1;
    resultIndex[1]=sLen+1;
    findMinMatch(dp, tLen, sLen, resultIndex);
    
    char* result=malloc(sizeof(char)*(resultIndex[1]-resultIndex[0]+2));
    int count=0;
    if (resultIndex[0]!=-1)
    {
        for (int i=resultIndex[0] ; i<=resultIndex[1] ; i++)
        {
                result[count++]=s[i];
        }
    }
    result[count]='\0';
    
    for (int i=0 ; i<tLen ; i++)
        free(dp[i]);
    free(dp);
    free(resultIndex);
    
    return result;
}
