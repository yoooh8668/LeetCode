int pairWithStart(char * s,int start){
    
    int  sLen = strlen(s);
    int  top = -1;
    int  currentMatch=start;
    
    //After called-function return, space will auto call free. We don't need to malloc a memory.
    char stack[sLen];
    //char* stack = (char*)malloc(sizeof(char)*sLen);

    for(int i=start;i<sLen;i++)
    {
        top = top + 1;
        stack[top] = s[i];
        if(s[i] == ')')    //if s[i] is end mark => check the stack if pairs with start mark
        {
            if(top>=1)  //stack is non-NULL
            {
                if(stack[top]-stack[top-1]==1)     //')' - '(' =1, pair condition
                {
                    top = top-2;    //pop element
                    if (top<0)      //if no element in stack, this is the longest pair with start for now.
                        currentMatch=i+1;
                }
                else //non pair
                {
                    return (i-start); 
                }
            }
            else     //stack is NULL && add a end mark
            {
                return (i-start);
            }
        }
    }
    if(top < 0)     //finish check end mark && stack is NULL
    {
        return (sLen-start);
    }
    //else return currentLen
    return (currentMatch-start);
}


int longestValidParentheses(char * s){
    int sLen = strlen(s);
    int currentLen = 0;
    int computeLen = 0;
    for (int i=0 ; i+currentLen < sLen-1 ; i++)
    {
        computeLen =pairWithStart(s,i);
        currentLen = ( currentLen >= computeLen ) ? currentLen : computeLen;
    }
    return currentLen;
}
